/**
 * Orchestra Mode
 *
 * Two-mode structured workflow:
 *
 * INIT mode: Takes a complex project description and creates:
 *   - ROADMAP.md ‚Äî phased task breakdown with status markers
 *   - WORK_LOG.md ‚Äî empty log ready for entries
 *   - Any other scaffold docs the project needs
 *   All delivered as a PR.
 *
 * RUN mode: Picks up the next task from ROADMAP.md (or a specific one):
 *   - Reads the roadmap to find the next uncompleted task
 *   - Implements the task
 *   - Creates a PR with code changes + updated ROADMAP.md + WORK_LOG.md entry
 */

// Orchestra task entry stored in R2
export interface OrchestraTask {
  taskId: string;
  timestamp: number;
  modelAlias: string;
  repo: string;            // owner/repo
  mode: 'init' | 'run';
  prompt: string;          // Original user prompt (truncated)
  branchName: string;      // Branch created
  prUrl?: string;          // PR URL if created
  status: 'started' | 'completed' | 'failed';
  filesChanged: string[];  // List of file paths touched
  summary?: string;        // AI-generated summary of what was done
}

// Per-user orchestra history stored in R2
export interface OrchestraHistory {
  userId: string;
  tasks: OrchestraTask[];
  updatedAt: number;
}

const MAX_HISTORY_TASKS = 30;

// Repo health check thresholds ‚Äî files above these limits should be split
// before the bot attempts modifications
export const LARGE_FILE_THRESHOLD_LINES = 300;
export const LARGE_FILE_THRESHOLD_KB = 15;

// Common file names the model should look for as existing roadmaps
const ROADMAP_FILE_CANDIDATES = [
  'ROADMAP.md',
  'roadmap.md',
  'TODO.md',
  'todo.md',
  'docs/ROADMAP.md',
  'docs/roadmap.md',
  'docs/status.md',
  '.github/ROADMAP.md',
];

// ============================================================
// INIT MODE ‚Äî Create roadmap + scaffold from project description
// ============================================================

/**
 * Build the system prompt for /orchestra init.
 * Instructs the model to analyze a project description and produce
 * a ROADMAP.md + WORK_LOG.md as a PR.
 */
export function buildInitPrompt(params: {
  repo: string;
  modelAlias: string;
}): string {
  const { repo, modelAlias } = params;
  const [owner, repoName] = repo.split('/');

  return `# Orchestra INIT Mode ‚Äî Project Roadmap Creation

You are creating a structured project roadmap. Follow this workflow precisely.

## Target Repository
- Owner: ${owner}
- Repo: ${repoName}
- Full: ${repo}

## Workflow

### Step 1: UNDERSTAND THE REPO
- Use \`github_list_files\` and \`github_read_file\` to understand:
  - Existing code structure, language, framework
  - Existing docs (README, CONTRIBUTING, etc.)
  - Any existing roadmap or TODO files: ${ROADMAP_FILE_CANDIDATES.join(', ')}
  - Test patterns, CI configuration
  - Package dependencies

### Step 1.5: FLAG LARGE FILES
- While exploring the repo, note any SOURCE files that exceed ~${LARGE_FILE_THRESHOLD_LINES} lines or ~${LARGE_FILE_THRESHOLD_KB}KB
- Only check source code files (.ts, .tsx, .js, .jsx, .py, .vue, .svelte, etc.) ‚Äî skip config, generated, and lock files
- If any large files are found, they MUST be split into smaller modules before other tasks modify them
- Record which files are large and what they contain (e.g., "src/App.tsx ‚Äî 800 lines, contains routing + all page components")

### Step 2: ANALYZE THE PROJECT REQUEST
- Read the user's project description carefully
- Break it down into concrete, implementable phases
- Each phase should have 2-5 specific tasks
- Order tasks by dependency (foundations first)

### Step 3: CREATE ROADMAP.md
Write a \`ROADMAP.md\` file with this exact format:

\`\`\`markdown
# Project Roadmap

> Auto-generated by Orchestra Mode | Model: ${modelAlias} | {date}

## Overview
{1-2 sentence project summary}

## Phases

### Phase 1: {phase name}
- [ ] **Task 1.1**: {task title}
  - Description: {what needs to be done}
  - Files: {likely files to create/modify}
  - Depends on: {none or task IDs}
- [ ] **Task 1.2**: {task title}
  ...

### Phase 2: {phase name}
- [ ] **Task 2.1**: {task title}
  ...

## Notes
{any architectural decisions, risks, or open questions}
\`\`\`

Key rules for the roadmap:
- Use \`- [ ]\` for pending tasks, \`- [x]\` for completed
- Task titles should be specific enough to act on (e.g., "Add JWT auth middleware" not "Handle auth")
- Include file hints so the next run knows where to work
- Include dependency info so tasks execute in order
- 3-6 phases is typical, each with 2-5 tasks
- **CRITICAL ‚Äî Large file splitting:** If Step 1.5 found any large files (>${LARGE_FILE_THRESHOLD_LINES} lines), add a "Refactor: Split {filename} into modules" task EARLY in the roadmap (Phase 1 or as the first task in the phase that would modify the file). All tasks that modify that file MUST depend on the split task. Example:
  \`- [ ] **Refactor**: Split src/App.tsx into route-level modules (~800 lines ‚Üí ~6 files)\`

### Step 4: CREATE WORK_LOG.md
Write a \`WORK_LOG.md\` file:

\`\`\`markdown
# Work Log

> Orchestra task execution history for ${repo}

| Date | Task | Model | Branch | PR | Status |
|------|------|-------|--------|-----|--------|
| {date} | Roadmap creation | ${modelAlias} | {branch} | {pr} | ‚úÖ |
\`\`\`

### Step 5: CREATE PR
- Include both ROADMAP.md and WORK_LOG.md in the PR
- If an existing roadmap file was found, update it instead of creating a new one
- Branch: \`roadmap-init-${modelAlias}\` (bot/ prefix added automatically)
- PR title: "feat: initialize project roadmap [${modelAlias}]"
- PR body: include the full roadmap content as preview, and a footer line: "Generated by: ${modelAlias}"
- Commit messages MUST include the model alias, e.g.: "feat: initialize project roadmap [${modelAlias}]"

### Step 6: REPORT
\`\`\`
ORCHESTRA_RESULT:
branch: {branch-name}
pr: {pr-url}
files: {comma-separated list of changed files}
summary: {1-2 sentence summary}
\`\`\`

## Rules
- Always create a PR ‚Äî never just describe what should be done
- If an existing roadmap exists, incorporate its content (don't discard previous work)
- Keep phases realistic ‚Äî avoid overplanning
- Task descriptions should be actionable by a coding AI model in a single session`;
}

// ============================================================
// RUN MODE ‚Äî Execute next task from roadmap
// ============================================================

/**
 * Build the system prompt for /orchestra run.
 * Instructs the model to read the roadmap, pick the next task,
 * implement it, and update the roadmap + work log in the same PR.
 */
export function buildRunPrompt(params: {
  repo: string;
  modelAlias: string;
  previousTasks: OrchestraTask[];
  specificTask?: string; // Optional: user-specified task instead of "next"
}): string {
  const { repo, modelAlias, previousTasks, specificTask } = params;
  const [owner, repoName] = repo.split('/');

  // Format previous task context
  let historyContext = '';
  if (previousTasks.length > 0) {
    const recent = previousTasks.slice(-5);
    const lines = recent.map(t => {
      const icon = t.status === 'completed' ? '‚úÖ' : t.status === 'failed' ? '‚ùå' : '‚è≥';
      const pr = t.prUrl ? ` ‚Üí ${t.prUrl}` : '';
      const sum = t.summary ? ` ‚Äî ${t.summary.substring(0, 100)}` : '';
      return `  ${icon} [${t.branchName}] "${t.prompt.substring(0, 80)}"${pr}${sum}`;
    });
    historyContext = `\n\n## Recent Orchestra History\n${lines.join('\n')}\n\nAvoid duplicating work already done.`;
  }

  const taskSelection = specificTask
    ? `The user has requested a SPECIFIC task: "${specificTask}"
Find this task (or the closest match) in the roadmap and execute it.
If the task is not in the roadmap, execute it anyway and add it to the roadmap as a completed item.`
    : `Find the NEXT uncompleted task in the roadmap:
- Look for the first \`- [ ]\` item whose dependencies are all satisfied (\`- [x]\`)
- If no roadmap exists, tell the user to run \`/orchestra init\` first
- If all tasks are completed, congratulate the user and suggest next steps`;

  return `# Orchestra RUN Mode ‚Äî Execute Next Roadmap Task

You are executing a task from the project roadmap. Follow this workflow precisely.

## Target Repository
- Owner: ${owner}
- Repo: ${repoName}
- Full: ${repo}

## Step 1: READ THE ROADMAP
- Use \`github_read_file\` to find and read the roadmap
- Check these paths in order: ${ROADMAP_FILE_CANDIDATES.join(', ')}
- Also read \`WORK_LOG.md\` if it exists
- If no roadmap is found, respond with: "No roadmap found. Run \`/orchestra init ${repo} <project description>\` first."

## Step 2: SELECT TASK
${taskSelection}

## Step 3: UNDERSTAND THE CODEBASE
- Use \`github_list_files\` and \`github_read_file\` to understand:
  - The files mentioned in the task
  - Related code and patterns
  - Existing conventions (naming, imports, types)
  - Test patterns if tests are expected

## Step 3.5: REPO HEALTH CHECK ‚Äî Large File Detection
Before implementing, check if any source file you need to modify is too large for safe editing.

**How to check:**
1. When you read files in Step 3, count the approximate line count
2. A file is "too large" if it has more than ~${LARGE_FILE_THRESHOLD_LINES} lines or ~${LARGE_FILE_THRESHOLD_KB}KB of source code
3. Config files, generated files, and lock files are exempt ‚Äî only check source code (.ts, .tsx, .js, .jsx, .py, .vue, .svelte, etc.)

**If you find a large file that your task needs to modify:**
1. STOP ‚Äî do NOT attempt the original task on the large file
2. Instead, implement a FILE SPLITTING task:
   - Split the large file into smaller, focused modules (each under ~${LARGE_FILE_THRESHOLD_LINES} lines)
   - Preserve all existing functionality ‚Äî this is a pure refactor
   - Update all imports across the codebase
   - Re-export from the original path if needed for backward compatibility
3. Update ROADMAP.md:
   - Add a new task: \`- [x] **Refactor**: Split {filename} into modules (~N lines ‚Üí M files)\`
   - Insert it BEFORE the original task you were going to do
   - Keep the original task as \`- [ ]\` (uncompleted) for the next run
4. In the PR title, prefix with "refactor:" and explain the split
5. In the ORCHESTRA_RESULT summary, note: "Auto-detected large file ({filename}, ~N lines). Split into modules. Original task deferred to next run."

**If all target files are reasonably sized (<${LARGE_FILE_THRESHOLD_LINES} lines):**
- Proceed normally to Step 4

This health check prevents failed or broken implementations caused by editing files too large for the AI context window.

## Step 4: IMPLEMENT
- Make the code changes using either:
  - \`github_create_pr\` for simple changes (up to ~10 files)
  - \`sandbox_exec\` for complex changes (clone, build, test, push)
- Follow existing code conventions
- Include proper types (no \`any\`)
- Write tests if the repo has a test pattern

### CRITICAL ‚Äî Surgical Edits Only
**NEVER regenerate or rewrite an entire file from scratch.** This is the most common failure mode.
- Make TARGETED, SURGICAL changes ‚Äî add/modify/remove only the specific lines needed for your task
- ALL existing exports, functions, classes, and variables MUST be preserved unless the task explicitly requires removing them
- If a file has \`exportCSV\`, \`btcPrice\`, \`businessClass\`, etc. ‚Äî those MUST still exist after your changes
- Before writing file content, mentally verify: "Does my new version still contain every function and export from the original?"
- If you cannot make targeted edits because the file is too complex or large, STOP and do a file-splitting refactor instead (see Step 3.5)
- The \`github_create_pr\` tool will BLOCK updates that lose more than 60% of original identifiers ‚Äî so regenerating from scratch will fail

## Step 5: UPDATE ROADMAP & WORK LOG
In the SAME PR, also include:

**ROADMAP.md update:**
- Change the completed task from \`- [ ]\` to \`- [x]\`
- Add completion note if relevant

**WORK_LOG.md update:**
- Append a new row to the table:
  \`| {date} | {task title} | ${modelAlias} | {branch} | {pr-url} | ‚úÖ |\`

## Step 6: CREATE PR
- Branch: \`{task-slug}-${modelAlias}\` (bot/ prefix added automatically)
- PR title: concise, under 70 chars, describes the task, MUST end with [${modelAlias}]
- PR body: include summary of changes, what roadmap task was completed, and a footer line: "Generated by: ${modelAlias}"
- Commit messages MUST include the model alias, e.g.: "feat(scope): description [${modelAlias}]"
- If using sandbox_exec, name branch: \`bot/{task-slug}-${modelAlias}\`

## Step 7: REPORT
\`\`\`
ORCHESTRA_RESULT:
branch: {branch-name}
pr: {pr-url}
files: {comma-separated list of changed files}
summary: {1-2 sentence summary including which roadmap task was completed}
\`\`\`

## Rules
- Always create a PR ‚Äî never just describe what should be done
- One task per run ‚Äî keep PRs focused
- ALWAYS update ROADMAP.md and WORK_LOG.md in the same PR as the code changes
- Use the model alias "${modelAlias}" in branch names for traceability
- Do NOT skip ahead ‚Äî respect task dependencies in the roadmap
- Do NOT modify unrelated files
- **NEVER regenerate entire files** ‚Äî make surgical, targeted edits only. Preserve all existing functions, exports, and business logic.
${historyContext}`;
}

// ============================================================
// LEGACY: buildOrchestraPrompt (kept for backward compat)
// ============================================================

/**
 * Build the orchestra system prompt (delegates to run mode).
 * @deprecated Use buildRunPrompt or buildInitPrompt directly.
 */
export function buildOrchestraPrompt(params: {
  repo: string;
  modelAlias: string;
  previousTasks: OrchestraTask[];
}): string {
  return buildRunPrompt(params);
}

// ============================================================
// Result parsing
// ============================================================

/**
 * Parse the ORCHESTRA_RESULT block from the model's final response.
 * Returns extracted metadata or null if not found.
 */
export function parseOrchestraResult(response: string): {
  branch: string;
  prUrl: string;
  files: string[];
  summary: string;
} | null {
  const match = response.match(/ORCHESTRA_RESULT:\s*\n([\s\S]*?)(?:```|$)/);
  if (!match) return null;

  const block = match[1];
  // Parse each field line-by-line to avoid cross-line matching
  const lines = block.split('\n');
  let branch = '';
  let prUrl = '';
  let filesLine = '';
  let summary = '';

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('branch:')) {
      branch = trimmed.slice('branch:'.length).trim();
    } else if (trimmed.startsWith('pr:')) {
      prUrl = trimmed.slice('pr:'.length).trim();
    } else if (trimmed.startsWith('files:')) {
      filesLine = trimmed.slice('files:'.length).trim();
    } else if (trimmed.startsWith('summary:')) {
      summary = trimmed.slice('summary:'.length).trim();
    }
  }

  const files = filesLine
    .split(',')
    .map(f => f.trim())
    .filter(Boolean);

  if (!branch && !prUrl) return null;

  return { branch, prUrl, files, summary };
}

// ============================================================
// Helpers
// ============================================================

/**
 * Generate a URL-safe task slug from a prompt.
 * Example: "Add dark mode toggle" ‚Üí "add-dark-mode-toggle"
 */
export function generateTaskSlug(prompt: string): string {
  return prompt
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .trim()
    .replace(/\s+/g, '-')
    .substring(0, 40)
    .replace(/-+$/, '');
}

/**
 * Parse the /orchestra command arguments.
 *
 * Formats:
 *   /orchestra init owner/repo <project description>
 *   /orchestra run owner/repo [specific task]
 *   /orchestra history
 *   /orchestra owner/repo <prompt>  (legacy, treated as run)
 */
export function parseOrchestraCommand(args: string[]): {
  mode: 'init' | 'run';
  repo: string;
  prompt: string;
} | null {
  if (args.length < 2) return null;

  const first = args[0].toLowerCase();

  // /orchestra init owner/repo <description>
  if (first === 'init') {
    if (args.length < 3) return null;
    const repo = args[1];
    if (!isValidRepo(repo)) return null;
    const prompt = args.slice(2).join(' ').trim();
    if (!prompt) return null;
    return { mode: 'init', repo, prompt };
  }

  // /orchestra run owner/repo [specific task]
  if (first === 'run') {
    if (args.length < 2) return null;
    const repo = args[1];
    if (!isValidRepo(repo)) return null;
    // Prompt is optional for run mode (defaults to "next task")
    const prompt = args.length > 2 ? args.slice(2).join(' ').trim() : '';
    return { mode: 'run', repo, prompt };
  }

  // Legacy: /orchestra owner/repo <prompt> (treated as run)
  const repo = args[0];
  if (!isValidRepo(repo)) return null;
  const prompt = args.slice(1).join(' ').trim();
  if (!prompt) return null;
  return { mode: 'run', repo, prompt };
}

/** Validate owner/repo format */
function isValidRepo(repo: string): boolean {
  return /^[a-zA-Z0-9_.-]+\/[a-zA-Z0-9_.-]+$/.test(repo);
}

// ============================================================
// R2 History Management
// ============================================================

/**
 * Load orchestra history from R2.
 */
export async function loadOrchestraHistory(
  r2: R2Bucket,
  userId: string
): Promise<OrchestraHistory | null> {
  const key = `orchestra/${userId}/history.json`;
  try {
    const obj = await r2.get(key);
    if (!obj) return null;
    return await obj.json() as OrchestraHistory;
  } catch {
    return null;
  }
}

/**
 * Store an orchestra task entry in R2 history.
 */
export async function storeOrchestraTask(
  r2: R2Bucket,
  userId: string,
  task: OrchestraTask
): Promise<void> {
  const key = `orchestra/${userId}/history.json`;

  let history: OrchestraHistory;
  try {
    const obj = await r2.get(key);
    if (obj) {
      history = await obj.json() as OrchestraHistory;
    } else {
      history = { userId, tasks: [], updatedAt: Date.now() };
    }
  } catch {
    history = { userId, tasks: [], updatedAt: Date.now() };
  }

  history.tasks.push(task);

  // Keep only the most recent tasks
  if (history.tasks.length > MAX_HISTORY_TASKS) {
    history.tasks = history.tasks.slice(-MAX_HISTORY_TASKS);
  }

  history.updatedAt = Date.now();
  await r2.put(key, JSON.stringify(history));
}

/**
 * Format orchestra history for display to the user.
 */
export function formatOrchestraHistory(history: OrchestraHistory | null): string {
  if (!history || history.tasks.length === 0) {
    return 'üìã No orchestra tasks yet.\n\nUsage:\n  /orchestra init owner/repo <project description>\n  /orchestra run owner/repo';
  }

  const lines: string[] = ['üìã Orchestra Task History\n'];

  for (const task of history.tasks.slice(-10).reverse()) {
    const status = task.status === 'completed' ? '‚úÖ' : task.status === 'failed' ? '‚ùå' : '‚è≥';
    const date = new Date(task.timestamp).toLocaleDateString();
    const modeTag = task.mode === 'init' ? ' [INIT]' : '';
    const pr = task.prUrl ? `\n   PR: ${task.prUrl}` : '';
    const summary = task.summary ? `\n   ${task.summary}` : '';
    lines.push(
      `${status} ${task.repo}${modeTag} ‚Äî ${task.prompt.substring(0, 60)}${task.prompt.length > 60 ? '...' : ''}` +
      `\n   ü§ñ /${task.modelAlias} | üåø ${task.branchName} | ${date}${pr}${summary}`
    );
  }

  return lines.join('\n\n');
}

// ============================================================
// Roadmap Status Display
// ============================================================

/**
 * Fetch the roadmap file from a GitHub repo.
 * Tries ROADMAP_FILE_CANDIDATES in order and returns the first found.
 */
export async function fetchRoadmapFromGitHub(
  owner: string,
  repo: string,
  githubToken?: string
): Promise<{ content: string; path: string }> {
  const headers: Record<string, string> = {
    'User-Agent': 'MoltworkerBot/1.0',
    'Accept': 'application/vnd.github.v3+json',
  };
  if (githubToken) {
    headers['Authorization'] = `Bearer ${githubToken}`;
  }

  for (const candidate of ROADMAP_FILE_CANDIDATES) {
    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${candidate}`;
    const response = await fetch(url, { headers });
    if (!response.ok) continue;

    const data = await response.json() as { content?: string; message?: string };
    if (!data.content) continue;

    const content = atob(data.content.replace(/\n/g, ''));
    return { content, path: candidate };
  }

  throw new Error('No roadmap file found. Run `/orch init` to create one.');
}

/** Parsed phase from a roadmap */
interface RoadmapPhase {
  name: string;
  tasks: { title: string; done: boolean }[];
}

/**
 * Parse a ROADMAP.md into phases and tasks.
 * Looks for `### Phase N: ...` headers and `- [x]`/`- [ ]` task lines.
 */
export function parseRoadmapPhases(content: string): RoadmapPhase[] {
  const phases: RoadmapPhase[] = [];
  let current: RoadmapPhase | null = null;

  for (const line of content.split('\n')) {
    // Match phase headers: "### Phase 1: Setup" or "### Phase 1 ‚Äî Setup"
    const phaseMatch = line.match(/^###\s+(?:Phase\s+\d+[:.‚Äî-]\s*)?(.+)/i);
    if (phaseMatch) {
      current = { name: phaseMatch[1].trim(), tasks: [] };
      phases.push(current);
      continue;
    }

    // Match task lines: "- [x] **Task 1.1**: ..." or "- [ ] Task title"
    const taskMatch = line.match(/^[-*]\s+\[([ xX])\]\s+(.+)/);
    if (taskMatch && current) {
      const done = taskMatch[1].toLowerCase() === 'x';
      // Strip bold task prefix like "**Task 1.1**: " or "**Title**:"
      const title = taskMatch[2]
        .replace(/^\*\*(?:Task\s+[\d.]+)?\*\*:?\s*/, '')
        .trim();
      current.tasks.push({ title, done });
    }
  }

  return phases;
}

/**
 * Format roadmap content into a concise status display for Telegram.
 * Shows per-phase progress with task checkmarks.
 */
export function formatRoadmapStatus(content: string, repo: string, filePath: string): string {
  const phases = parseRoadmapPhases(content);

  if (phases.length === 0) {
    // No structured phases found ‚Äî show raw content (truncated)
    const preview = content.length > 3000 ? content.slice(0, 3000) + '\n\n[Truncated]' : content;
    return `üìã Roadmap ‚Äî ${repo}\nüìÑ ${filePath}\n\n${preview}`;
  }

  const lines: string[] = [`üìã Roadmap Status ‚Äî ${repo}`];
  lines.push(`üìÑ ${filePath}\n`);

  let totalDone = 0;
  let totalTasks = 0;

  for (const phase of phases) {
    const done = phase.tasks.filter(t => t.done).length;
    const total = phase.tasks.length;
    totalDone += done;
    totalTasks += total;

    const phaseDone = total > 0 && done === total;
    const phaseIcon = phaseDone ? '‚úÖ' : done > 0 ? 'üî®' : '‚è≥';
    lines.push(`${phaseIcon} ${phase.name} (${done}/${total})`);

    for (const task of phase.tasks) {
      lines.push(`  ${task.done ? '‚úÖ' : '‚¨ú'} ${task.title}`);
    }
    lines.push('');
  }

  // Overall progress bar
  const pct = totalTasks > 0 ? Math.round((totalDone / totalTasks) * 100) : 0;
  const filled = Math.round(pct / 10);
  const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(10 - filled);
  lines.push(`‚îÅ‚îÅ‚îÅ Overall: ${totalDone}/${totalTasks} tasks (${pct}%)`);
  lines.push(`[${bar}]`);

  return lines.join('\n');
}

// ============================================================
// Roadmap Reset / Redo
// ============================================================

/**
 * Find tasks in roadmap content that match a query string.
 * Matches against task titles (case-insensitive, substring match).
 * Also matches "Phase N" to select all tasks in a phase.
 */
export function findMatchingTasks(
  content: string,
  query: string
): { lineIndex: number; title: string; done: boolean; phase: string }[] {
  const matches: { lineIndex: number; title: string; done: boolean; phase: string }[] = [];
  const queryLower = query.toLowerCase().trim();
  const lines = content.split('\n');

  // Check if the query targets a whole phase (e.g. "Phase 2" or "phase 2")
  const phaseQuery = queryLower.match(/^phase\s+(\d+)$/i);

  let currentPhase = '';
  let currentPhaseNum = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Track current phase
    const phaseMatch = line.match(/^###\s+(?:Phase\s+(\d+)[:.‚Äî-]\s*)?(.+)/i);
    if (phaseMatch) {
      currentPhaseNum = phaseMatch[1] ? parseInt(phaseMatch[1], 10) : currentPhaseNum + 1;
      currentPhase = phaseMatch[2]?.trim() || `Phase ${currentPhaseNum}`;
      continue;
    }

    // Match task lines
    const taskMatch = line.match(/^[-*]\s+\[([ xX])\]\s+(.+)/);
    if (taskMatch && currentPhase) {
      const done = taskMatch[1].toLowerCase() === 'x';
      const rawTitle = taskMatch[2]
        .replace(/^\*\*(?:Task\s+[\d.]+)?\*\*:?\s*/, '')
        .trim();

      // Check if this task matches the query
      const titleLower = rawTitle.toLowerCase();
      const fullLineLower = line.toLowerCase();

      if (phaseQuery) {
        // Phase-level match: select all tasks in the matching phase
        if (currentPhaseNum === parseInt(phaseQuery[1], 10)) {
          matches.push({ lineIndex: i, title: rawTitle, done, phase: currentPhase });
        }
      } else if (
        titleLower.includes(queryLower) ||
        fullLineLower.includes(queryLower)
      ) {
        matches.push({ lineIndex: i, title: rawTitle, done, phase: currentPhase });
      }
    }
  }

  return matches;
}

/**
 * Reset (uncheck) matching tasks in roadmap content.
 * Returns modified content and info about what was reset.
 */
export function resetRoadmapTasks(
  content: string,
  query: string
): { modified: string; resetCount: number; taskNames: string[] } {
  const matches = findMatchingTasks(content, query);

  // Only reset tasks that are currently done
  const toReset = matches.filter(m => m.done);

  if (toReset.length === 0) {
    return { modified: content, resetCount: 0, taskNames: [] };
  }

  const lines = content.split('\n');
  const taskNames: string[] = [];

  for (const match of toReset) {
    // Replace [x] or [X] with [ ]
    lines[match.lineIndex] = lines[match.lineIndex].replace(/\[([xX])\]/, '[ ]');
    taskNames.push(match.title);
  }

  return {
    modified: lines.join('\n'),
    resetCount: toReset.length,
    taskNames,
  };
}

/**
 * Create a GitHub PR that resets roadmap task checkboxes.
 * Uses the GitHub Git Data API (same pattern as github_create_pr tool).
 */
export async function createRoadmapResetPR(params: {
  owner: string;
  repo: string;
  filePath: string;
  newContent: string;
  taskNames: string[];
  githubToken: string;
}): Promise<{ prUrl: string; branch: string }> {
  const { owner, repo, filePath, newContent, taskNames, githubToken } = params;

  const headers: Record<string, string> = {
    'User-Agent': 'MoltworkerBot/1.0',
    'Accept': 'application/vnd.github.v3+json',
    'Authorization': `Bearer ${githubToken}`,
    'Content-Type': 'application/json',
  };

  const apiBase = `https://api.github.com/repos/${owner}/${repo}`;
  const branchName = `bot/roadmap-reset-${Date.now()}`;

  // Step 1: Get base branch SHA
  const refResponse = await fetch(`${apiBase}/git/ref/heads/main`, { headers });
  if (!refResponse.ok) {
    throw new Error(`Failed to get main branch: ${refResponse.status}`);
  }
  const refData = await refResponse.json() as { object: { sha: string } };
  const baseSha = refData.object.sha;

  // Step 2: Create blob with updated content
  const blobResponse = await fetch(`${apiBase}/git/blobs`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ content: newContent, encoding: 'utf-8' }),
  });
  if (!blobResponse.ok) {
    throw new Error(`Failed to create blob: ${blobResponse.status}`);
  }
  const blobData = await blobResponse.json() as { sha: string };

  // Step 3: Create tree
  const treeResponse = await fetch(`${apiBase}/git/trees`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      base_tree: baseSha,
      tree: [{ path: filePath, mode: '100644', type: 'blob', sha: blobData.sha }],
    }),
  });
  if (!treeResponse.ok) {
    throw new Error(`Failed to create tree: ${treeResponse.status}`);
  }
  const treeData = await treeResponse.json() as { sha: string };

  // Step 4: Create commit
  const commitMsg = taskNames.length === 1
    ? `fix(roadmap): reset task "${taskNames[0]}"`
    : `fix(roadmap): reset ${taskNames.length} tasks`;
  const commitResponse = await fetch(`${apiBase}/git/commits`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ message: commitMsg, tree: treeData.sha, parents: [baseSha] }),
  });
  if (!commitResponse.ok) {
    throw new Error(`Failed to create commit: ${commitResponse.status}`);
  }
  const commitData = await commitResponse.json() as { sha: string };

  // Step 5: Create branch
  const createRefResponse = await fetch(`${apiBase}/git/refs`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ ref: `refs/heads/${branchName}`, sha: commitData.sha }),
  });
  if (!createRefResponse.ok) {
    throw new Error(`Failed to create branch: ${createRefResponse.status}`);
  }

  // Step 6: Create pull request
  const prBody = `Resetting roadmap tasks:\n${taskNames.map(t => `- [ ] ${t}`).join('\n')}\n\nThese tasks will be picked up by the next \`/orch next\` run.`;
  const prResponse = await fetch(`${apiBase}/pulls`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      title: commitMsg,
      head: branchName,
      base: 'main',
      body: prBody,
    }),
  });
  if (!prResponse.ok) {
    throw new Error(`Failed to create PR: ${prResponse.status}`);
  }
  const prData = await prResponse.json() as { html_url: string };

  return { prUrl: prData.html_url, branch: branchName };
}

// ============================================================
// REDO MODE ‚Äî Re-execute a previously completed task
// ============================================================

/**
 * Build the system prompt for /orchestra redo.
 * Like run mode, but instructs the model to treat the specified task
 * as incomplete and re-implement it, regardless of checkbox state.
 */
export function buildRedoPrompt(params: {
  repo: string;
  modelAlias: string;
  previousTasks: OrchestraTask[];
  taskToRedo: string;
}): string {
  const { repo, modelAlias, previousTasks, taskToRedo } = params;
  const [owner, repoName] = repo.split('/');

  let historyContext = '';
  if (previousTasks.length > 0) {
    const recent = previousTasks.slice(-5);
    const lines = recent.map(t => {
      const icon = t.status === 'completed' ? '‚úÖ' : t.status === 'failed' ? '‚ùå' : '‚è≥';
      const pr = t.prUrl ? ` ‚Üí ${t.prUrl}` : '';
      const sum = t.summary ? ` ‚Äî ${t.summary.substring(0, 100)}` : '';
      return `  ${icon} [${t.branchName}] "${t.prompt.substring(0, 80)}"${pr}${sum}`;
    });
    historyContext = `\n\n## Recent Orchestra History\n${lines.join('\n')}\n\nThe most recent attempt at this task may have been incorrect. Do NOT repeat the same mistakes.`;
  }

  return `# Orchestra REDO Mode ‚Äî Re-implement a Task

You are RE-DOING a task that was previously attempted but needs correction.

## Target Repository
- Owner: ${owner}
- Repo: ${repoName}
- Full: ${repo}

## Task to Redo
"${taskToRedo}"

## CRITICAL INSTRUCTIONS
1. This task was previously attempted but the result was INCORRECT or INCOMPLETE.
2. Treat this task as UNCOMPLETED regardless of its checkbox state in the roadmap.
3. Read the EXISTING code carefully to understand what the previous attempt did wrong.
4. Re-implement the task PROPERLY from scratch if needed, or fix the existing attempt.

## Step 1: READ THE ROADMAP
- Use \`github_read_file\` to find and read the roadmap
- Check these paths in order: ${ROADMAP_FILE_CANDIDATES.join(', ')}
- Find the task matching: "${taskToRedo}"
- If the task is marked \`- [x]\`, change it back to \`- [ ]\` in your PR

## Step 2: UNDERSTAND CURRENT STATE
- Use \`github_list_files\` and \`github_read_file\` to examine:
  - The files that were modified by the previous attempt
  - The current state of the code
  - What is wrong or missing
  - Test failures if any

## Step 2.5: REPO HEALTH CHECK
Before re-implementing, check if the target file(s) are too large (>${LARGE_FILE_THRESHOLD_LINES} lines / ~${LARGE_FILE_THRESHOLD_KB}KB of source code).
If so, split the large file into smaller modules FIRST (pure refactor, no behavior change), then proceed with the redo on the now-smaller files.
Update the roadmap to reflect the split as a completed prerequisite task.

## Step 3: RE-IMPLEMENT
- Fix or rewrite the implementation
- Follow existing code conventions
- Include proper types (no \`any\`)
- Write/fix tests if the repo has a test pattern

### CRITICAL ‚Äî Surgical Edits Only
**NEVER regenerate or rewrite an entire file from scratch.** This is the most common failure mode.
- Make TARGETED, SURGICAL changes ‚Äî add/modify/remove only the specific lines needed
- ALL existing exports, functions, classes, and variables MUST be preserved unless the task explicitly requires removing them
- Before writing file content, mentally verify: "Does my new version still contain every function and export from the original?"
- If you cannot make targeted edits, STOP and do a file-splitting refactor first
- The \`github_create_pr\` tool will BLOCK updates that lose more than 60% of original identifiers

## Step 4: UPDATE ROADMAP & WORK LOG
In the SAME PR:

**ROADMAP.md update:**
- Mark the task as \`- [x]\` (completed)
- Add a note: "(redone)" next to the task

**WORK_LOG.md update:**
- Append: \`| {date} | REDO: {task title} | ${modelAlias} | {branch} | {pr-url} | ‚úÖ |\`

## Step 5: CREATE PR
- Branch: \`redo-{task-slug}-${modelAlias}\` (bot/ prefix added automatically)
- PR title: "fix: redo {task title} [${modelAlias}]"
- PR body: explain what was wrong with the previous attempt and what was fixed, and a footer line: "Generated by: ${modelAlias}"
- Commit messages MUST include the model alias, e.g.: "fix(scope): redo description [${modelAlias}]"

## Step 6: REPORT
\`\`\`
ORCHESTRA_RESULT:
branch: {branch-name}
pr: {pr-url}
files: {comma-separated list of changed files}
summary: {what was wrong and how it was fixed}
\`\`\`

## Rules
- Always create a PR ‚Äî never just describe what should be done
- Focus on FIXING the previous attempt, not starting from zero (unless necessary)
- ALWAYS update ROADMAP.md and WORK_LOG.md in the same PR
- Do NOT modify unrelated files
- **NEVER regenerate entire files** ‚Äî make surgical, targeted edits only. Preserve all existing functions, exports, and business logic.
${historyContext}`;
}
